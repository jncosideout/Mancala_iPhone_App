//
//  MancalaGameModel.swift
//  MancalaPrototype2
//
//  Created by Alexander Scott Beaty on 7/30/19.
//  Copyright Â© 2019 Alexander Scott Beaty. All rights reserved.
//

import Foundation
import GameKit
/**
    Encapsulates all game logic, game data and management of game data for saving and loading
 */
class GameModel: NSObject {//removed Codable ASB 06/29/19 //changed struct to class, added NSCoding 7/27/19
    ///Records the player who has won the game or 0 if tied
    var winner: Int?
    ///The gameboard that the game is played on
    var pits: CircularLinkedList<PitNode>
    ///The representative of Player 1
    let mancalaPlayer1: MancalaPlayer
    ///The representative of Player 2
    let mancalaPlayer2: MancalaPlayer
    ///A pointer to the MancalaPlayer whose turn it is to act
    var _activePlayer: MancalaPlayer
    /**
        Stores the return value from playPhase1() that counts the number of beads in the pit chosen by the player initiating a move
     
        The value is mainly used for updating the UI according to how many pits had beads placed into them
     */
    var updateTokenNodes = 0
    ///Keeps track of whose turn it is in the game
    var playerTurn: Int
    
    ///Stores the return value from playPhase2() for **Player1**
    ///
    ///Since the game ends when one player clears their side, ```sum1``` is compared to 0 at the end of each turn
    var sum1 = 0
    
    ///Stores the return value from playPhase2() for **Player2**
    ///
    ///Since the game ends when one player clears their side, ```sum2``` is compared to 0 at the end of each turn
    var sum2 = 0
    
    ///A message of the status of the game.
    ///
    ///- Can be set by playPhase2() in a normal turn ("*it's Player 1's turn,"* or "*Game Over*"),
    ///- or copied from text stored in a MancalaPlayer (```captureText, bonusTurnText```)
    var playerTurnText = ""
    
    ///Stores the series of messages generated by playPhase2() at the end of the game
    var winnerTextArray = [String]()
    
    ///Used to allign the the gameboard in GameScene according to whose turn it is
    ///
    ///* debug: set = 2 to start with player 2 on bottom
    var playerPerspective: Int
    
    ///Stores all data members for persistence
    var gameData: GameData
    
    ///Records the number of times Player 1 has taken a turn
    var turnNumber: Int
    
    /**Stores the list of moves by the last active player. Used primary to animate the last move in ReplayScene
     
        - keys are PlayerID: Int
        - values are pit.name: String
     */
    var lastMovesList: [[Int : String]]
    
    ///Records who was the last player
    ///
    ///Used by GameCenterHelper.assignOutcomes()
    var lastPlayerTurn = 1
    
    /**
      True if this GameModel is used in a "VS Computer" match
     
     This flags when the playerTurnText needs to be replaced for a "VS Computer" match
     */
    var vsAI = false
    
    /**
     True if this GameModel is used in an Online Match
    
    This flags when the playerTurnText needs to be replaced for an Online Match
    */
    var vsOnline = false
    
    ///Signifies whether Player 1 or 2 is the local player in an Online match
    ///
    ///Primarily used when playerTurnText is personalized for the local player
    var localPlayerNumber = 0
    
    /**
     This flag signals the match's ```currentParticipant``` to officially end the match
     
     Because the GKLocalPlayer no longer calls GKTurnBasedMatch.endMatchInTurn,
     but instead passes the match to the other player with endTurn(), this flag is necessary for the next player to officially end the match
     */
    var onlineGameOver = false
    
    //for GKGameModel AI
    ///Records the player, if any, who got a bonus turn
    ///
    ///Allows GKGameModel AI extension to determine the number of pits available that have potential to get a bonus turn
    var bonusForPlayer: Int?
    ///Records the player, if any, who got a capture
    ///
    ///Allows GKGameModel AI extension to determine the number of pits available that have potential to get a capture
    var captureForPlayer: Int?
    ///Container of the ```MancalaPlayer```s in this game
    ///
    ///The AI needs this as a reference to both players when calling bestMove(for:)
    var allPlayers: [MancalaPlayer]? = nil
    ///Constant declaring the side-length of the ```pits``` gameboard
    ///
    ///Do not override this value. It is used by the buildGameBoard functions to determine how many pits to create per player
    static let pitsOnEachSideNotIncludingBase = 6
    ///Coordinates to layout the board in the UI from *Player 1's* perspective
    ///
    ///- The buildGameBoard functions provide these coordinates to the pitsNodes in the ```pits``` gameboard
    ///- When the GameScene renders the BoardNode, these coordinates are translated into CGPoints on the node
    static let player1Perspective = [
        GridCoordinate(x: .mid1, y: .min),//Ply 1 Pit 1
        GridCoordinate(x: .mid2, y: .min),
        GridCoordinate(x: .mid3, y: .min),
        GridCoordinate(x: .mid4, y: .min),//Ply 1 Pit 4
        GridCoordinate(x: .mid5, y: .min),
        GridCoordinate(x: .mid6, y: .min),
        
        GridCoordinate(x: .max, y: .mid),//base P1
        
        GridCoordinate(x: .mid6, y: .max),//Ply 2 Pit 1
        GridCoordinate(x: .mid5, y: .max),
        GridCoordinate(x: .mid4, y: .max),
        GridCoordinate(x: .mid3, y: .max),//Ply 2 Pit 4
        GridCoordinate(x: .mid2, y: .max),
        GridCoordinate(x: .mid1, y: .max),
        
        GridCoordinate(x: .min, y: .mid),//base P2
    ]
    ///Coordinates to layout the board in the UI from *Player 2's* perspective
    ///
    ///- The buildGameBoard functions provide these coordinates to the pitsNodes in the ```pits``` gameboard
    ///- When the GameScene renders the BoardNode, these coordinates are translated into CGPoints on the node
    static let player2Perspective = [//player 2's perspective, P1 on top
        GridCoordinate(x: .mid6, y: .max),//Ply 1 Pit 1
        GridCoordinate(x: .mid5, y: .max),
        GridCoordinate(x: .mid4, y: .max),
        GridCoordinate(x: .mid3, y: .max),//Ply 1 Pit 4
        GridCoordinate(x: .mid2, y: .max),
        GridCoordinate(x: .mid1, y: .max),
        
        GridCoordinate(x: .min, y: .mid),//base P1
        
        GridCoordinate(x: .mid1, y: .min),//Ply 2 Pit 1
        GridCoordinate(x: .mid2, y: .min),
        GridCoordinate(x: .mid3, y: .min),
        GridCoordinate(x: .mid4, y: .min),//Ply 2 Pit 4
        GridCoordinate(x: .mid5, y: .min),
        GridCoordinate(x: .mid6, y: .min),
        
        GridCoordinate(x: .max, y: .mid),//base P2
    ]
    
    /**
        Returns the appropriate text to display in the GameScene
     
        The state of the GameModel is used to determine which message gets returned
     */
    var messageToDisplay: String {
        var returnString = ""
        
        if isCapturingPiece {
            if let captureText = _activePlayer.captureText {
                returnString = captureText
            } else {
                returnString = "Captured!"
            }
        } else if hasBonusTurn {
            if let bonusText = _activePlayer.bonusTurnText {
                returnString = bonusText
            } else {
                returnString = "Bonus turn!"
            }
        } else {
            returnString = playerTurnText
        }
        
        if vsAI {
            returnString = replaceTextAI(for: playerTurn, in: returnString)
        } else if vsOnline, playerTurn == localPlayerNumber {
            returnString = replaceTextOnlineMatch(for: localPlayerNumber, in: returnString)
        }
        
        return returnString
    }
    
    ///True if the current player captured
    var isCapturingPiece: Bool {
        return _activePlayer.captured > 0
    }
    
    ///True if the current player got a bonus turn
    var hasBonusTurn: Bool{
        return _activePlayer.bonusTurn
    }
    
    ///True if the last player captured
    ///
    ///Switches _activePlayer to the last player to check its ```captured``` amount, then switches back to the current player
    var lastPlayerCaptured: Bool {
        switchActivePlayer()
        let hadCapture = _activePlayer.captured > 0
        switchActivePlayer()
        return hadCapture
    }
    
    ///True if the last player got a bonus turn
    ///
    ///Switches _activePlayer to the last player  to check its ```bonusTurn``` value, then switches back to the current player
    var lastPlayerBonusTurn: Bool {
        switchActivePlayer()
        let hadBonus = _activePlayer.bonusTurn
        switchActivePlayer()
        return hadBonus
    }
    
    ///The captureText of the last player
    ///
    ///Switches _activePlayer to the last player to return its ```captureText``` , then switches back to the current player
    var lastPlayerCaptureText: String? {
        switchActivePlayer()
        let captureText = _activePlayer.captureText
        switchActivePlayer()
        return captureText
    }
    
    ///The bonusTurnText of the last player
    ///
    ///Switches _activePlayer to the last player to return its ```bonusTurnText``` , then switches back to the current player
    var lastPlayerBonusText: String? {
        switchActivePlayer()
        let bonusText = _activePlayer.bonusTurnText
        switchActivePlayer()
        return bonusText
    }
    
    
    //MARK: Initializers
    /**
     This init is called to get a fresh game model.
     - Parameter newGame: set true to initialize the ```pits``` gameboard for a new game. If ```newGame``` is false,  ```pits``` will be empty, so you must provide a gameboard using one of the buildGameboard functions
     */
  init(newGame: Bool) { //new game
        gameData = GameData()
        playerTurn = gameData.playerTurn
        playerPerspective = gameData.playerPerspective
        mancalaPlayer1 = MancalaPlayer(player: 1)
        mancalaPlayer2 = MancalaPlayer(player: 2)
        _activePlayer = playerTurn == 1 ? mancalaPlayer1 : mancalaPlayer2
        pits = CircularLinkedList<PitNode>()
        
        if newGame {
            pits = GameModel.buildGameboard(pitsPerPlayer: GameModel.pitsOnEachSideNotIncludingBase)
        }
        turnNumber = gameData.turnNumber
        playerTurnText = gameData.playerTurnText
        lastMovesList = gameData.lastMovesList

    }
    
    /**
        Used to initialize the inherited GameModel of the ReplayScene
     
        The ReplayScene manipulates its inherited GameModel to perform the replay()
     - Parameters:
     - gameData: should come from the ReplayScene's ```actualModel```
     */
    init(replayWith gameData: GameData) {
        self.gameData = gameData
        if let _playerTurn = gameData.lastMovesList.first?.keys.first {
            playerTurn = _playerTurn
        } else {
            playerTurn = gameData.playerTurn == 1 ? 2 : 1
        }//playerTurn should now be equal to the last player who moved, who's turn is being replayed
        
        playerPerspective = gameData.playerPerspective
        mancalaPlayer1 = MancalaPlayer(player: 1)
        mancalaPlayer2 = MancalaPlayer(player: 2)
        _activePlayer = playerTurn == 1 ? mancalaPlayer1 : mancalaPlayer2//our opponent
        pits = GameModel.initGameboard(from: gameData.oldPitsList)//coming from opponent
        turnNumber = gameData.turnNumber
        playerTurnText = gameData.playerTurnText
        lastMovesList = gameData.lastMovesList
        onlineGameOver = gameData.onlineGameOver
    }
    
    /**
     Initializes a GameModel from completely from gameData.
     
     Mainly useful for loading saved games from a ```GameData``` source
     */
    convenience init(from gameData: GameData) {
        self.init(newGame: true)
        self.gameData = gameData
        setUpGame(from: gameData)
        
    }
    
    /**
     Initializes from GKTurnBasedMatch.matchData
     
     Call this initializer in SKSCeneExtension.loadAndDisplay or whatever method gets a GKTurnBasedMatch object from receives a GKTurnBasedMatch object from GKLocalPlayerListener.player(_:receivedTurnEventFor:didBecomeActive)
     - Parameter gkMatchData: This is GameData that was deserialized from ```GKTurnBasedMatch.matchData``` after calling ```GKTurnBasedMatch.loadMatchData```
     */
    convenience init(fromGKMatch gkMatchData: GameData) {
        self.init(from: gkMatchData)
        turnNumber = gameData.turnNumber
        onlineGameOver = gameData.onlineGameOver
        printBoard(pits)
    }
   
    /**
     Sets most of the values of the GameModel. Allows a GameModel to be reused with new values coming from the ```gameData``` parameter
     
     Use ```resetGame``` after this to completely reset the GameModel and its MancalaPlayers
     ## Assigns the following using ```gameData```:
     * playerTurn
     * _activePlayer
     * playerPerspective
     * winner
     * playerTurnText
     * winnerTextArray
     
     - Parameter gameData: If this GameData has a non-empty pitsList, it will be used to build the ```pits``` gameboard. Otherwise a new gameboard is created
     */
    func setUpGame(from gameData: GameData) {
        if gameData.pitsList.count > 0 {
            pits = GameModel.initGameboard(from: gameData.pitsList)
        } else {
            pits = GameModel.buildGameboard(pitsPerPlayer: GameModel.pitsOnEachSideNotIncludingBase)
        }
        playerTurn = gameData.playerTurn
        _activePlayer = playerTurn == 1 ? mancalaPlayer1 : mancalaPlayer2
        playerPerspective = gameData.playerPerspective
        winner = gameData.winner
        playerTurnText = gameData.playerTurnText
        winnerTextArray = gameData.winnerTextArray
    }
    
    /**
     Use this with ```setUpGame``` to completely clean a GameModel
     
     Allows a GameModel to be reused with new values
     ## Resets the following data members
     * mancalaPlayer1
     * mancalaPlayer2
     * updateTokenNodes
     * sum1
     * sum2
     * playerTurnText
     * winnerTextArray
     * turnNumber
     * lastMovesList
     
     ## GKGameModel AI related vars
     * bonusForPlayer
     * captureForPlayer
     */
    func resetGame() {
        mancalaPlayer1.resetPlayer()
        mancalaPlayer2.resetPlayer()
        updateTokenNodes = 0
        sum1 = 0
        sum2 = 0
        playerTurnText = ""
        winnerTextArray = [String]()
        turnNumber = 0
        lastMovesList = [[Int : String]]()
        
        //GKGameModel AI
        bonusForPlayer = 0
        captureForPlayer = 0
    }
    
    /**
     Should be called by a newly initialized GameModel.
     
     Not all essential data members are copied.
     - Postcondition: The members of the model passed as an argument to this method are copied to the calling GameModel
    */
    func copyModel(from model: GameModel) {
        pits = model._activePlayer.copyBoard(from: model.pits)
        playerTurn = model.playerTurn
        _activePlayer = playerTurn == 1 ? mancalaPlayer1 : mancalaPlayer2
        playerPerspective = model.playerPerspective
        winner = model.winner
        playerTurnText = model.playerTurnText
    }
    
    /**
     Loads saved games from disk. Each saved games GameData should be managed by the SavedGameStore.
     
     - Parameter url: Should be a constant stored in SavedGameStore
     */
    func loadSavedGame(from url: URL) {
        if let nsData = NSData(contentsOf: url) {
            do {
                let data = Data(referencing: nsData)
                gameData = try JSONDecoder().decode(GameData.self, from: data)
                pits = GameModel.initGameboard(from: gameData.pitsList)
                playerTurn = gameData.playerTurn
                _activePlayer = playerTurn == 1 ? mancalaPlayer1 : mancalaPlayer2
                playerTurnText = gameData.playerTurnText
                winner = gameData.winner
                winnerTextArray = gameData.winnerTextArray
            } catch {
                print("error loading gameData: \(error)")
            }
        } else {
            print("no data in url")
            pits = GameModel.buildGameboard(pitsPerPlayer: GameModel.pitsOnEachSideNotIncludingBase)
        }
    }
    
    //MARK: play functions
    
    /**
     First primary gameplay method. Every turn begins in this method.
     
     + Important: Always follow this with a call to playPhase2()
     + Returns: The number of beads in parameter ```pit```. Use this value to inform GameScene how many pits to animate.
     + Parameters:
        + player: The Player ID {1,2} who initiated a move
        + pit: The name of the pit chosen by the ```player```
     */
    @discardableResult func playPhase1 (_ player: Int,_ pit: String ) -> Int{
        lastMovesList.append([player : pit])
        bonusForPlayer = nil
        captureForPlayer = nil
        
        if player != _activePlayer.player || pit == "BASE" {
            return -1
        }
        clearAllPreviousBeads()
        updateTokenNodes = _activePlayer.fillHoles(pit, pits)
        
        return updateTokenNodes
    }
    
    /**
     Second primary gameplay method. Every turn ends with a call to this method.
     
     Handles the rest of the game logic following ```playPhase1(_:_)```. You should not assume the state of the game after this method is called. If you have any business logic to inject after a player "sows seeds" in ```playPhase1(_:_)``` but which you need to execute before the game determines who goes next or whether the game has ended, do so before calling this method.
     
     + Important: Always preceed a call to this method with a call to ```playPhase1(_:_)```
     + Returns: ```playerTurnText``` if the game has not ended.
     */
    @discardableResult func playPhase2() -> String {
        lastPlayerTurn = playerTurn
        var bonus_count = 0
        var bonus = false
        bonus = determineBonusAndCapture()
        
        repeat {
            playerTurn = (playerTurn == 1) ? 2 : 1//change turn
            switchActivePlayer()
            bonus_count += 1 //to switch back if bonus true
        } while (bonus_count < 2 && bonus)
        
        sum1 = mancalaPlayer1.sumPlayerSide(pits)
        sum2 = mancalaPlayer2.sumPlayerSide(pits)
        
        print("Player 1 remaining = \(sum1) \nPlayer 2 remaining = \(sum2) \n \n")
        print("After fill holes \n\n")
        printBoard(pits)
        
        if 0 == sum1 || 0 == sum2 {
            determineWinner(sum1, sum2)
            return ""
        } else {
            playerTurnText = ""
            playerTurnText += "Player \(playerTurn)'s turn."
            print(playerTurnText)
            if vsAI {
                playerTurnText = replaceTextAI(for: playerTurn, in: playerTurnText)
            } else if vsOnline, playerTurn == localPlayerNumber {
                playerTurnText = replaceTextOnlineMatch(for: localPlayerNumber, in: playerTurnText)
            }
            return playerTurnText
        }
    }
    
    /**
     Checks the state of the active player before play has passed to the next active player
     */
    func determineBonusAndCapture() -> Bool{
        if _activePlayer.bonusTurn {
            bonusForPlayer = _activePlayer.playerId
        }
        
        if _activePlayer.captured > 0 {
            captureForPlayer = _activePlayer.playerId
        }
        
        return _activePlayer.bonusTurn
    }
    
    /**
     Only called when the game has ended. Do not use this to determine whether the game has ended.
     
     + Postcondition:Has three outcomes:
     1. ```winnerTextArray``` is populated
     2. ```clearingPlayerTakesAll(from: )``` is called
     3.  The ```bonusTurnText``` and ```captureText``` of both Player 1 and 2 are set to nil
     */
    func determineWinner(_ sum1: Int, _ sum2: Int) {
        if hasBonusTurn {
        //advance playerTurn to next player because the winner ended on a bonus turn
            //this prevents ReplayMode playerPerspective from being incorrect
            playerTurn = playerTurn == 1 ? 2 : 1
        }
        var message = "game over"
        winnerTextArray.append(message)
        playerTurnText = message
        print(playerTurnText + "\n")
        winner = nil
        do {
            let iter_base_1 = try mancalaPlayer1.findPit("BASE", pits)
            let iter_base_2 = try mancalaPlayer2.findPit("BASE", pits)
            
            if let pit_base1 = *iter_base_1, let pit_base2 = *iter_base_2 {
                var message1 = { () -> String in
                    var text = "Player 1"
                    if self.vsAI { text = "Your" }
                    return text + " base = \(pit_base1.beads)"
                }()
                var message2 = { () -> String in
                    var text = "Player 2"
                    if self.vsAI { text = "Computer's" }
                    return text + " base = \(pit_base2.beads)"
                }()
                winnerTextArray.append(message1)// + "  " + message2)
                winnerTextArray.append(message2)
                playerTurnText = message1 + "\n" + message2 +  "\n\n"
                print(playerTurnText)
                
                if 0 == sum1{
                    clearingPlayerTakesAll(from: 2)
                    pit_base1.beads += sum2
                } else {
                    clearingPlayerTakesAll(from: 1)
                    pit_base2.beads += sum1
                }
                
                if pit_base1.beads == pit_base2.beads {
                    //tie
                    winner = 0
                } else if pit_base1.beads > pit_base2.beads {
                    winner = 1
                } else {
                    winner = 2 }
                
                message = "Final totals are"
                message1 = { () -> String in
                    var text = "Player 1"
                    if self.vsAI { text = "You" }
                    return text + " = \(pit_base1.beads)"
                }()
                message2 = { () -> String in
                    var text = "Player 2"
                    if self.vsAI { text = "Computer" }
                    return text + " = \(pit_base2.beads)"
                }()
                winnerTextArray.append(message)// + " " + message1 + "  " + message2)
                winnerTextArray.append(message1)
                winnerTextArray.append(message2)
                playerTurnText = message + "\n " + message1 + "\n " + message2 + "\n\n"
                print(playerTurnText)
                
                if let theWinner = winner, theWinner != 0 {
                    playerTurnText = "The winner is Player \(theWinner)! Good work. :)"
                    if vsAI {
                        if theWinner == 1 {
                            playerTurnText = "You win! Good work. :)"
                        } else {
                            playerTurnText = "Computer wins! I'm smart. :D"
                        }
                    } else if vsOnline, theWinner == localPlayerNumber {
                        playerTurnText = "You win! Good work. :)"
                    }
                    winnerTextArray.append(playerTurnText)
                    print(playerTurnText  + " \n")
                } else {
                    playerTurnText = "Tie game. Way to go... :|"
                    winnerTextArray.append(playerTurnText)
                    print(playerTurnText + " \n")
                }
            } else {
                print("pit_base 1 or 2 was nil")
            }
        } catch let error {
            fatalError(error.localizedDescription)
        }
        gameData.winner = winner ?? nil
        gameData.playerTurnText = playerTurnText
        gameData.winnerTextArray = winnerTextArray
        mancalaPlayer1.bonusTurnText = nil
        mancalaPlayer1.captureText = nil
        mancalaPlayer2.bonusTurnText = nil
        mancalaPlayer2.captureText = nil
    }
    
    /**
     Removes all beads from ```player```'s pits and adds them to the other player's "BASE"
     
     When one player ends the game by clearing his side (he has no more moves to make), the tradition of Kalah/Mancala is to remove all the beads from the pits of the remaining player and add them to the base of the player whose side has been emptied first.
     
     - This method should only be called from within ```determineWinner()```
     */
    private func clearingPlayerTakesAll(from player: Int) {
        
        let iterator = pits.circIter
        
        for _ in 1...pits.length {
            if let pit = *iterator {
                if pit.player == player && pit.name != "BASE" {
                    pit.beads = 0
                    if pit.mostRecentBeads < 0 {
                        pit.mostRecentBeads = 0
                    }
                }
            }
            ++iterator
        }
    }
    
    /**
     Helper method to point _activePlayer to the next player
     */
    func switchActivePlayer(){//change players to take next turn
        _activePlayer = _activePlayer.player == 2 ? mancalaPlayer1 : mancalaPlayer2
    }
    
    /**
     Personalizes the ```playerTurnText``` before it is presented to the user in a VS Computer match
     */
    func replaceTextAI(for player: Int, in givenText: String) -> String {
        var replacementString = ""
        var findString = "Player"
        if player == 1 {
            findString += " 1"
        } else {
            findString += " 2"
            replacementString = "Computer"
        }
        if player == 1 {
            return replacePlayerText(findString, in: NSString(string: givenText))
        }
        if givenText.contains(findString) {
            return replaceSubstring(findString, in: NSString(string: givenText), with: replacementString)
        }
        return givenText
    }
    
    /**
    Personalizes the ```playerTurnText``` before it is presented to the user in an Online match
    */
    func replaceTextOnlineMatch(for player: Int, in givenText: String) -> String {
        var findString = "Player"
        if player == 1 {
            findString += " 1"
        } else {
            findString += " 2"
        }
        return replacePlayerText(findString, in: NSString(string: givenText))
    }
    
    /**
    Personalizes the ```playerTurnText``` before it is presented to the user
    */
    func replacePlayerText(_ findString: String, in givenText: NSString) -> String {
        var replacementString = ""
        var _findString = findString
        
        if givenText.contains(_findString) {
            //when playerText contains "Player X's turn"
            if givenText.contains(_findString + "'s") {
                _findString += "'s"
                replacementString = "Your"
            //when playerText contains "Player X gets a bonus"
            } else {
                //when playerText contains "Player X gets a bonus turn!"
                if givenText.contains(_findString + " gets") {
                    _findString += " gets"
                    replacementString = "You get"
                } else {
                    //when playerText contains "Player X captured"...
                    replacementString = "You"
                }
            }
            return replaceSubstring(_findString, in: givenText, with: replacementString)
        }
        return givenText as String
    }
    
    /**
     Helper function to replace text in ```givenText``` which matches ```_findString```
     */
    public func replaceSubstring(_ _findString: String, in givenText: NSString, with replacementString: String) -> String {
        var _givenText = givenText as String
        if let range = _givenText.range(of: _findString) {
            _givenText.replaceSubrange(range, with: replacementString)
        }
        return _givenText
    }
    
    //MARK: board setup
    
    /**
     Loads a ```pits``` gameboard with existing data in ```pitsList```
     
     - Important: The first index of ```pitsList``` must be equal to Player 2's "BASE" pit
     */
    static func initGameboard(from pitsList: [PitNode]) -> CircularLinkedList<PitNode> {
        let pitsCLL = CircularLinkedList<PitNode>()
        
        let checkPit = PitNode(player: 2, name: "BASE")
        
        guard pitsList.count > 0 else {
            fatalError("pitsList.count = \(pitsList.count)")
        }
        guard pitsList[0] == checkPit else {
            print("pitsList[0] not equal to BASE pit of player 2. \nGot: \(pitsList[0]) instead")
            return pitsCLL
        }
        
        for pit in pitsList {
            let copyOfPit = pit.copyPit()
            pitsCLL.enqueue(copyOfPit)
        }
        if pitsCLL.length != 14 {
            fatalError("Expected pitsCLL length = 14, got \(pitsCLL.length)")
        }
        pitsCLL.advanceLast()  // to point 'last' at Player 2's BASE
        return pitsCLL
    }
    
    /**
     Initializes a new ```pits``` gameboard to start a new game
     */
    static func buildGameboard(pitsPerPlayer: Int ) -> CircularLinkedList<PitNode> {
        let pitsCLL = CircularLinkedList<PitNode>()
        
        for player in 1...2 {
            for pit in 1...pitsPerPlayer + 1{
                
                let pitN = PitNode()
                pitN.player = player
                
                if pit == pitsPerPlayer + 1 {
                    pitN.beads = 0
                    pitN.name = "BASE"
                } else {
                    pitN.beads = UserDefaults.numberOfStartingBeads
                    pitN.name = String(pit)
                }
                
                if player == 1 {
                    pitN.coordP1 = player1Perspective[pit - 1]
                    pitN.coordP2 = player2Perspective[pit - 1]
                } else {
                    pitN.coordP1 = player1Perspective[pit + pitsPerPlayer]
                    pitN.coordP2 = player2Perspective[pit + pitsPerPlayer]
                }
                pitN.previousBeads.popLast()
                pitsCLL.enqueue(pitN)//place pit in pits
            }
        }
        
        return pitsCLL
    }
    
    /**
    For debugging purposes only. Initializes a new ```pits``` gameboard to using preset values that are intended to be changed within this class method
    */
    static func buildGameboardTEST(pitsPerPlayer: Int ) -> CircularLinkedList<PitNode> {
        let pits = CircularLinkedList<PitNode>()
        
        for player in 1...2 {
            for pit in 1...pitsPerPlayer + 1{
                
                let pitN = PitNode()
                pitN.player = player
                
                if player == 1 {
                    if pit == 1 {
                        pitN.beads = 12
                        pitN.name = String(pit)
                    } else if pit == 2 {
                        pitN.beads = 12
                        pitN.name = String(pit)
                    } else if pit == 3 {
                        pitN.beads = 11
                        pitN.name = String(pit)
                    } else if pit == 4 {
                        pitN.beads = 10
                        pitN.name = String(pit)
                    } else if pit == 5 {
                        pitN.beads = 1
                        pitN.name = String(pit)
                    } else if pit == 6 {
                        pitN.beads = 1
                        pitN.name = String(pit)
                    } else if pit == 7 {
                        pitN.beads = 7
                        pitN.name = "BASE"
                    }
                } else {    //player 2
                    if pit == 1 {
                        pitN.beads = 5
                        pitN.name = String(pit)
                    } else if pit == 2 {
                        pitN.beads = 4
                        pitN.name = String(pit)
                    } else if pit == 3 {
                        pitN.beads = 3
                        pitN.name = String(pit)
                    } else if pit == 4 {
                        pitN.beads = 2
                        pitN.name = String(pit)
                    } else if pit == 5 {
                        pitN.beads = 1
                        pitN.name = String(pit)
                    } else if pit == 6 {
                        pitN.beads = 0
                        pitN.name = String(pit)
                    } else if pit == 7 {
                        pitN.beads = 5
                        pitN.name = "BASE"
                    }
                }
                
                if player == 1 {
                    pitN.coordP1 = GameModel.player1Perspective[pit - 1]
                    pitN.coordP2 = GameModel.player2Perspective[pit - 1]
                } else {
                    pitN.coordP1 = GameModel.player1Perspective[pit + pitsPerPlayer]
                    pitN.coordP2 = GameModel.player2Perspective[pit + pitsPerPlayer]
                }
                pitN.previousBeads.popLast()
                pits.enqueue(pitN)//place pit in pits
            }
        }
        return pits
    }
    
    /**
    For debugging purposes only. Meant to simulate the last few moves of a game. Initializes a new ```pits``` gameboard to using preset values that are intended to be changed within this class method
    */
    static func buildGameboardTEST_END_GAME(pitsPerPlayer: Int ) -> CircularLinkedList<PitNode> {
        let pits = CircularLinkedList<PitNode>()
        
        for player in 1...2 {
            for pit in 1...pitsPerPlayer + 1{
                
                let pitN = PitNode()
                pitN.player = player
                
                if player == 1 {
                    if pit == 1 {
                        pitN.beads = 0
                        pitN.name = String(pit)
                    } else if pit == 2 {
                        pitN.beads = 0
                        pitN.name = String(pit)
                    } else if pit == 3 {
                        pitN.beads = 0
                        pitN.name = String(pit)
                    } else if pit == 4 {
                        pitN.beads = 0
                        pitN.name = String(pit)
                    } else if pit == 5 {
                        pitN.beads = 1
                        pitN.name = String(pit)
                    } else if pit == 6 {
                        pitN.beads = 1
                        pitN.name = String(pit)
                    } else if pit == 7 {
                        pitN.beads = 30
                        pitN.name = "BASE"
                    }
                } else {    //player 2
                    if pit == 1 {
                        pitN.beads = 0
                        pitN.name = String(pit)
                    } else if pit == 2 {
                        pitN.beads = 1
                        pitN.name = String(pit)
                    } else if pit == 3 {
                        pitN.beads = 3
                        pitN.name = String(pit)
                    } else if pit == 4 {
                        pitN.beads = 6
                        pitN.name = String(pit)
                    } else if pit == 5 {
                        pitN.beads = 7
                        pitN.name = String(pit)
                    } else if pit == 6 {
                        pitN.beads = 8
                        pitN.name = String(pit)
                    } else if pit == 7 {
                        pitN.beads = 32
                        pitN.name = "BASE"
                    }
                }
                
                if player == 1 {
                    pitN.coordP1 = GameModel.player1Perspective[pit - 1]
                    pitN.coordP2 = GameModel.player2Perspective[pit - 1]
                } else {
                    pitN.coordP1 = GameModel.player1Perspective[pit + pitsPerPlayer]
                    pitN.coordP2 = GameModel.player2Perspective[pit + pitsPerPlayer]
                }
                pitN.previousBeads.popLast()
                pits.enqueue(pitN)//place pit in pits
            }
        }
        return pits
    }
    
    /**
     Utility method for debugging and for command line output
     */
    private func printBoard(_ gameboard: CircularLinkedList<PitNode>) {
        
        let myIter = gameboard.circIter
        
        ++myIter
        
        for _ in 1...pits.length {
            
            if let tempPit = *myIter {
                print("player:  \(tempPit.player)  pit name: \(tempPit.name) num beads: \(tempPit.beads)")
            } else {
                print("myIter could not get pit")
            }
            ++myIter
        }
        print("")
    }
    
    /**
     Must be called after every turn. The ```previousBeads``` array only works correctly if it is empty before each turn.  The```previousBeads``` array is just used for animating pits in a wrap-around scenario. This benefits the GameScene.
     */
    func clearAllPreviousBeads() {
        let boardIterator = pits.circIter
        for _ in 0..<pits.length {
            let pit = *boardIterator
            pit?.previousBeads.removeAll()
            ++boardIterator
        }
    }
    
    // MARK: - saving data
    
    /**
     Copies all major vars from this GameModel to its ```gameData```
     */
    func saveGameData() {
        gameData.playerTurn = playerTurn
        gameData.playerTurnText = playerTurnText
        gameData.winner = winner
        gameData.winnerTextArray = winnerTextArray
        gameData.pitsList.removeAll()
        gameData.pitsList = saveGameBoardToList(pits)
        gameData.playerPerspective = playerPerspective
        gameData.lastMovesList = lastMovesList
        gameData.onlineGameOver = onlineGameOver
    }
    
    /**
     Saves the ```gameData``` of this individual GameModel. Primarily called by GameCenterHelper
     */
    func saveDataToSend(overwriteAllGameData: Bool = true) -> Data {
        if overwriteAllGameData {
            saveGameData()
        }
        var data = Data()
        print("saving gameboard to send to opponent")
        do {
            try data = JSONEncoder().encode(gameData)
            return data
        } catch {
            print("error saving game data to send: \(error)" )
        }
        
        return data
    }
    
    /**
     Used for saving a gameboard in a serializable form. Does not delete ```pits``` when finished.
     - Parameter pits: a gameboard that will be copied to a list of ```PitNode```s
     - Returns: A list of ```PitNode```s where the first ```PitNode``` should be Player 2's "BASE"
     */
    func saveGameBoardToList(_ pits: CircularLinkedList<PitNode>) -> [PitNode] {
        guard pits.length > 0 else {
            fatalError("in saveGameBoardToList(), pits.lenth = \(pits.length)")
        }
        let copiedBoard = _activePlayer.copyBoard(from: pits)
        var pitsList = [PitNode]()
        var i = 0
        while !pits.isEmpty || i < pits.length {
            if let pit = copiedBoard.dequeue() {
                pitsList.append(pit)
            } else {
                break
            }
            i += 1
        }
        _ = pitsList.popLast()
        
        return pitsList
    }
    
}//EoC



// MARK: - Types

extension GameModel {

    /**
     The relative Y axis position of a pit on the BoardNode SKNode
     */
    enum GridPosition_Y: Int, Codable {
        case min, mid, max
    }
    
    /**
    The relative X axis position of a pit on the BoardNode SKNode
     
    -  min and max are used for Player 1 or 2's "BASE" (depending on ```playerPerspective```)
     - mid1-6 are used for the pits on each side between the players' "BASE"s
    */
    enum GridPosition_X: Int, Codable {
        case min, mid1, mid2, mid3, mid4, mid5, mid6, max
    }
    
    private struct GridCoordKeys {
        static let x = "x"
        static let y = "y"
    }
    
    /**
     Allows GameScene to place a pit in the correct BoardPointNode for the UI
     */
    public struct GridCoordinate: Codable, Equatable {
        public init(x: GridPosition_X = .min, y: GridPosition_Y = .min){
            self.x = x
            self.y = y
        }
        
        public var x: GridPosition_X
        public var y: GridPosition_Y
        
    }
    
    /**
     Possible outdated.
     */
    struct Token:  Equatable {
        let coord: GridCoordinate
        var pit: PitNode
    }
   
}
